
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module frequency_meter_Nios_display(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW ///////////
	input 		     [9:0]		SW,
	
	////////  LVDS  ///////
	output 							lvds_freq,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	inout 		    [35:0]		GPIO_1,
	
	input SPI_SS,
	input SPI_SCK,
	input SPI_DIN,
	output SPI_DOUT
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire cout_i, cout_b, clk_base, clk_in;
reg freq_en = 0, count_en = 0, led_out = 0;
reg [7:0] count_clk;
wire [31:0] freq_mem; //регистр-хранилище для данных об измеряемой частоте

assign lvds_freq = clk_in;

wire clk_1, clk_2, clk_3, clk_0;

assign clk_in = clk_2;

reg [31:0] freq_base;//MHz

logic [31:0] time_del;

assign freq_base = SW[0] ? 31'd50_000_000 : 31'd200_000_000;

assign time_del = SW[3:1];// + 1'b1;

//=======================================================
//  Structural coding
//=======================================================

/*Nios_display_system u0 (
	  .clk_clk       (CLOCK_50),       //   clk.clk
	  .reset_reset_n (KEY[0]), // reset.reset_n
	  .key_export    (KEY[3:1]),    //   key.export
	  .led_export    (LEDR),     //   led.export
	  .sdram_addr    (DRAM_ADDR),    // sdram.addr
	  .sdram_ba      (DRAM_BA),      //      .ba
	  .sdram_cas_n   (DRAM_CAS_N),   //      .cas_n
	  .sdram_cke     (DRAM_CKE),     //      .cke
	  .sdram_cs_n    (DRAM_CS_N),    //      .cs_n
	  .sdram_dq      (DRAM_DQ),      //      .dq
	  .sdram_dqm     ({DRAM_UDQM,DRAM_LDQM}),     //      .dqm
	  .sdram_ras_n   (DRAM_RAS_N),   //      .ras_n
	  .sdram_we_n    (DRAM_WE_N),     //      .we_n
	  .sdram_clk_clk (DRAM_CLK),
	  .lcd_data_export (GPIO_1[20:13]), //  lcd_data.export
	  .lcd_e_export    (GPIO_1[12]),    //     lcd_e.export
	  .lcd_rs_export   (GPIO_1[10]),   //    lcd_rs.export
	  .lcd_rw_export   (GPIO_1[11]),   //    lcd_rw.export
	  .sw_export       (SW),        //        sw.export
	  .freq_export		 (freq_mem),     	//     freq.export
	  .freq_en_export  (freq_en)  //   freq_en.export

 );*/
 
 PLL_base pll_base
 (
	
	.refclk(CLOCK_50),
	.rst(~KEY[0]),
	.outclk_0(clk_base),
	//.outclk_1(clk_in)
	
 );
 PLL_temp pll_temp
 (
	.refclk(CLOCK_50),
	.rst(~KEY[0]),
	.outclk_0(clk_0),
	.outclk_1(clk_1),
	.outclk_2(clk_2),
	.outclk_3(clk_3)
 );
 
 freq_m_module freq_meter
(
	
	.clk_base(clk_base),
	.clk_in(clk_in),
	.freq_base(freq_base),
	.time_del(time_del),
	.freq_mem(freq_mem),
	.cout_i(cout_i),
	.cout_b(cout_b)
	
);

/*always @(posedge clk_base)
begin
	
	if (cout_b == 1'b1)
	begin
		
		freq_en = 1'b1;
		count_en = 1'b1;
		
	end
	
	if (count_en == 1'b1) count_clk = count_clk + 1'b1;
	
	if (count_clk == 8'd100)
	begin
		
		freq_en = 1'b0;
		count_en = 1'b0;
		count_clk = 8'b0;
		
	end
	
end*/

///////  SPI ////////////


reg rstb, aset;
/*rstb - сигнал reset SPI
  aset - сигнал асинхронного сброса счётчика байтов для SPI*/

wire done;//сигнал завершения отправки очередного байта по SPI
reg [7:0] tdata = 8'b0;//регистр, содержащий данный, отправляемые по SPI

wire [3:0] i; //номер отправленного байта (изменяется от 0 до 3), необходим для побайтной отправки 32-битного числа

//выключение SPI до момента первого рассчитанного значения частоты
initial
begin

	rstb = 1'b0;
	aset = 1'b1;	
end


//Включение SPI, когда появилось первое значение частоты
always @(posedge cout_b)
begin

	rstb = 1'b1;
	aset = 1'b0;
	
end

//Передача на SPI поочерёдно 4 байт значения частоты
always @(posedge done)
begin

	case (i)
		0: tdata = freq_mem[7 : 0];
		1: tdata = freq_mem[15 : 8];
		2: tdata = freq_mem[23 : 16];
		3: tdata = freq_mem[31 : 24];
	endcase
	
end

//Счётчик номера байта
Counter_4 count_n_freq
 (
	
	.clock(done),
	.q(i),
	.aset(aset)
	
 );

//Отладочные светодиоды, отражающие правильное подключение линий SPI (загораются в момент передачи данных)
assign LEDR[1] = ~SPI_SS;
assign LEDR[2] = SPI_SCK;

//Подключение модуля SPI (модуль разработан не мной, там комментариев нет)
 spi_slave spi
(
	
	.rstb(rstb),	//Сброс SPI
	.ten(1'b1),		//Разрешение передачи
	.tdata(tdata),	//Регистр для передачи данных
	.mlb(1'b1),		//С какого бита начинается передача по SPI
	.ss(SPI_SS),			//slave select
	.sck(SPI_SCK),		//SPI clk
	.sdin(SPI_DIN),	//data in
	.sdout(SPI_DOUT),	//data out
	.done(done),	//сигнал завершения передачи одного байта
	
);

always @(posedge cout_b)
begin
	
	led_out = led_out + 1'b1;
	
end

assign LEDR[0] = led_out;

endmodule
